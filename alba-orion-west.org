#+OPTIONS: ':nil *:t -:t ::t <:t H:4 \n:nil ^:{} arch:headline
#+OPTIONS: author:t c:nil creator:nil d:(not "LOGBOOK") date:t e:t
#+OPTIONS: email:nil f:t inline:t num:t p:nil pri:nil prop:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:t title:t toc:t todo:t |:t
#+TITLE: Notes on creating spectral maps from Orion West slit spectra
#+AUTHOR: William Henney
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport

#+PROPERTY: header-args    :exports both


* Dealing with the offset between image and spectrum
+ It seems that this is not as constant as I had hoped
  + In the [[id:8685D060-12A9-4E73-B069-11D5315ED8EB][vertical slits]] it varies from 52 to 60 pixels
  + And some slits do not have a reference star to use
+ One solution will be to compare the brightness profiles of the spectrum with that of the slit image
  + For the spectrum, we can sum in wavelength for the entire ha+nii range
  + For the image, we would sum a short width across the slit
+ Then we could either use the cross-correlation, or simple hunting, to find the best offset
+ At the same time, this would give the brightness factor between image and spec
  + We could use this to refine the brightness correction factors


** Application to the vertical slits
:PROPERTIES:
:dir:      ~/Dropbox/SPMJAN10/reducciones
:ID:       0B8D02D8-4C57-48A1-8F17-6AD60BFA1A7B
:END:
#+name: vertical-image-and-fullspec
| image |    spec | islit | jshift |  fac |  bfac |
|-------+---------+-------+--------+------+-------|
|   202 | 203-204 | 233.6 |   52.5 |  3.9 | 1.143 |
|   124 | 125-127 | 235.5 |   54.5 |  2.7 | 1.431 |
|   206 | 207-208 | 234.6 |     54 |  4.4 | 1.136 |
|   128 | 129-130 | 237.5 |     57 |  4.4 | 2.688 |
|   133 | 134-135 | 239.4 |     58 |    5 | 1.608 |
|   210 | 211-212 | 236.4 |     55 |  4.4 | 1.021 |
|   137 | 138-139 | 241.3 |     60 |  2.8 | 1.550 |
|   214 | 215-216 | 238.4 |     55 |  4.1 | 1.067 |
|   145 | 146-147 | 244.3 |     58 |  2.0 | 5.181 |
|   248 | 249-250 | 254.9 |     68 |  5.4 | 2.222 |
|   219 | 220-221 | 240.0 |   57.5 | 4.35 |     1 |
|   157 | 158-159 | 252.2 |     65 |  7.0 | 6.757 |
|   236 | 237-238 | 247.0 |     63 |  4.2 | 1.122 |
|   240 | 241-242 | 249.5 |     65 |  3.1 | 1.073 |
|   244 | 245-246 | 251.6 |     64 |  2.7 | 1.147 |
|   252 | 253-254 | 258.2 |     69 |  5.4 | 1.678 |

+ Pixel positions of slits (islit in table above) also vary between positions, so I have had to measure all of these
  + They are FITS style 1-based indices
  + The slit width is about 4 pixels
  + But the slit center does not fall on an integer pixel
  + To be safe, we take the 5 pixels: [int(islit) - 3 : int(islit) + 3] 
+ First stab:
  + Read in the images and spectra, and overplot the profiles
  + There are 16 positions now, so we can use a 4 x 4 grid
  + The =bfac= factors are the inter-position image brightness correction factors, calculated below - they multiply all the brightnesses
    + On the graphs, I print out =bright = 1/bfac=
  + The =fac= factors are the image-to-spectrum brightness factors - they multiply the image profile so that it matches the spectrum profile
    + So larger factors mean better spectra (compared to what is expected from the image)
    + The most common factor /should/ correspond to equal conditions between image and spectrum. But in general =fac= could be larger or smaller than this.
    + I am assuing that =fac = 4.4= is the default value, and dividing all of them by this when I print the info on the plot
      + There are 4 spectra that have the optimum value of =bfac=:
        + 206, 128, 210, 219
      + Most of the other values are lower
        + This make sense if conditions were deteriorating during the night
        + Then each spectrum is worse than its preceding image
      + But a few are higher, implying improvements since the image:
        + 133, 248, 157, 252
        + These tend to have high values of bfac

#+header: :var table=vertical-image-and-fullspec
#+BEGIN_SRC python :return figfile :results file
  from astropy.io import fits
  import numpy as np
  import matplotlib.pyplot as plt
  import seaborn as sns; sns.set()
  sns.set_color_codes()

  nspec = 12
  ny = 512
  figfile = 'image-spec-offsets.pdf'
  yarray = np.arange(ny)
  layout = {'left': 0.05, 'bottom': 0.07, 'right': 0.99, 'top': 0.95,
            'wspace': 0.02, 'hspace': 0.02}
  fig, axgrid = plt.subplots(4, 4, sharex=True, sharey=True, gridspec_kw=layout)
  tweak = 1.2
  for (imid, specid, islit, jshift, factor, bfac), ax in zip(table, axgrid.flat):
      imfile = 'posiciones/spm{}-ardec.fits'.format(imid)
      specfile = 'spm{}h.fits'.format(specid)
      islit = int(float(islit))
      jshift = float(jshift)
      factor = float(factor)
      bfac = float(bfac)

      imhdu, = fits.open(imfile)
      spechdu, = fits.open(specfile)
  
      imhdu.data -= 1170.0  # remove bias
      improfile = imhdu.data[:, islit-3:islit+3].sum(axis=1)
      specprofile = spechdu.data.sum(axis=1)
 
      ax.plot(yarray+jshift, bfac*improfile/(1e4*tweak), label='image',
              c='r', lw=2, alpha=0.3)
      ax.plot(yarray, bfac*specprofile/(1e4*factor), label='spectrum',
              c='k', lw=0.6)

      text_pattern = 'pos #{} shift = {:.1f} factor = {:.2f} bright = {:.2f}'
      text = text_pattern.format(imid, jshift, factor/4.4, 1.0/bfac)
      ax.text(300, 0.1, text, ha='center', va='bottom', fontsize=7)

  axgrid[0, 0].legend(fontsize='xx-small', loc='upper left')
  axgrid[0, 0].set_xlim(0.0, 640)
  axgrid[0, 0].set_ylim(0.0, 5.5)
  axgrid[-1, 2].set_xlabel('pixel')
  axgrid[1, 0].set_ylabel('intensity')
  fig.suptitle('Alignment and flux calibration of vertical slits')
  fig.set_size_inches(11, 8.5)
  fig.savefig(figfile)


#+END_SRC

#+RESULTS:
[[file:/Users/will/Dropbox/SPMJAN10/reducciones/image-spec-offsets.pdf]]


** Repeat for the horizontal slits
:PROPERTIES:
:dir:      ~/Dropbox/SPMFEB13/WesternShocks
:END:

#+name: horizontal-image-and-fullspec
| image |    slit |  night | jslit | dj | ishift | fac | bfac |
|-------+---------+--------+-------+----+--------+-----+------|
|   165 | 166-167 | 160213 | 468.5 | 12 |     67 | 5.5 |    1 |
|   169 | 170-171 | 160213 | 468.5 | 12 |     65 | 5.3 |    1 |
|   237 | 238-239 | 160213 | 467.0 | 12 |     74 | 5.5 |    1 |
|   232 | 233-234 | 160213 | 468.5 | 12 |     75 | 5.8 |    1 |
|   226 | 227-228 | 160213 | 468.5 | 12 |     75 | 6.0 |    1 |
|   149 | 150-151 | 160213 | 468.0 | 12 |     70 | 5.0 |    1 |
|   154 | 155-156 | 160213 | 467.2 | 12 |     67 | 5.2 |    1 |
|   159 | 160-161 | 160213 | 467.5 | 12 |     67 | 5.4 |    1 |
|   033 | 034-035 | 150213 | 467.0 | 12 |     67 | 5.5 |    1 |
|   029 | 030-031 | 150213 | 465.2 |  6 |     76 | 6.0 |    1 |

+ [2015-08-21 Fri] I have measured the y-pixel position of the slit (=jslit=) on the images - it is roughly constant, but not quite
  + We have to be careful to use the "Image" coordinate, not the "Physical" one
+ The slit width is 150 micron for all exept =029= where it is 70 micron
  + This is reflected in the nominal pixel width of the slit, which is given in the =dj= column
  + The slit profile is not rectangular - looks more triangular, or perhaps an ellipse
+ The bias seems to have been removed, but there is a residual signal in the image+slits of 6 to 12 counts, which varies in J but not in I
  + At the J of the slit it looks to be about 9
+ It is hard to tell whether there is anything that should be removed from the spectra
  + But looking at the x-profiles of the line-free parts of the PV image, as compared with the Ha line, I think there is a residual bias of about 3
  + When multiplied by NY=1017, this gives 3051 as the value that should be subtracted from the y-summed profile
+ I have found a better way to extract the slit profile from the image:
  + Sum over a wide window that includes the /entire/ slit profile
  + But then subtract off the average of the two rows above and below this window, multiplied by the window width
  + This is equivalent to interpolating the bg underneath the slit profile
  + It seems to give better results than the previous method

#+header: :var table=horizontal-image-and-fullspec
#+BEGIN_SRC python :return figfile :results file
  from astropy.io import fits
  import numpy as np
  import matplotlib.pyplot as plt
  import seaborn as sns; sns.set()
  sns.set_color_codes()

  nspec = 10
  nx = 625
  figfile = 'image-spec-offsets.pdf'
  xarray = np.arange(nx)
  layout = {'left': 0.05, 'bottom': 0.07, 'right': 0.99, 'top': 0.95,
            'wspace': 0.02, 'hspace': 0.02}
  fig, axgrid = plt.subplots(2, 5, sharex=True, sharey=True, gridspec_kw=layout)
  tweak = 1.0
  for (imid, specid, night, jslit, dj, ishift, factor, bfac), ax in zip(table, axgrid.flat):
      imfile = 'spm{:03d}_ardec.fits'.format(imid)
      specfile = '../{}/reducciones/spm{}_bcr.fits'.format(night, specid)
      jslit = int(float(jslit))
      dj = int(dj)
      ishift = float(ishift)
      factor = float(factor)
      bfac = float(bfac)

      imhdu, = fits.open(imfile)
      spechdu, = fits.open(specfile)
  
      imhdu.data -= 9.0  # remove residual bias
      spechdu.data -= 5.5
      # limits of slit (FWZI)
      j1, j2 = jslit-dj//2, jslit+dj//2
      improfile = imhdu.data[j1:j2, :].sum(axis=0)
      # take average profile either side of the slit
      offprofile = 0.5*(imhdu.data[j1-1, :] + imhdu.data[j2, :])
      # and subtract (multiplied by slit width) to get the pure slit profile
      improfile -= dj*offprofile
      specprofile = spechdu.data.sum(axis=0)
 
      ax.plot(xarray-ishift, (12.0/dj)*bfac*improfile/(1e4*tweak), label='image',
      c='r', lw=2, alpha=0.3)
      ax.plot(xarray, bfac*specprofile/(1e4*factor), label='spectrum',
              c='k', lw=0.6)

      text_pattern = 'pos #{} shift = {:.1f} factor = {:.2f} bright = {:.2f}'
      text = text_pattern.format(imid, ishift, factor/5.5, 1.0/bfac)
      ax.text(300, 0.1, text, ha='center', va='bottom', fontsize=7)

  axgrid[0, 0].legend(fontsize='xx-small', loc='upper left')
  axgrid[0, 0].set_xlim(-80, 640)
  axgrid[0, 0].set_ylim(0.0, 1.5)
  axgrid[-1, 2].set_xlabel('pixel')
  axgrid[1, 0].set_ylabel('intensity')
  fig.suptitle('Alignment and flux calibration of horizontal slits')
  fig.set_size_inches(11, 8.5)
  fig.savefig(figfile)


#+END_SRC

#+RESULTS:
[[file:/Users/will/Dropbox/SPMFEB13/WesternShocks/image-spec-offsets.pdf]]


* Datasets that we will use
** Dec 2014
** Dec 2013
** Feb 2013
** Jan 2010
:LOGBOOK:
CLOCK: [2015-08-16 Sun 18:29]--[2015-08-16 Sun 19:04] =>  0:35
:END:
+ Copied files to [[file:~/Dropbox/SPMJAN10/reducciones/][~/Dropbox/SPMJAN10/reducciones/]]
+ Looking at which ones to use to see if I agree with Tere
*** WCS values and per-slit weighting
+ Alba's coordinates seem to be for the center of the slit in the image+slit
+ dWav = 0.043752133846283 Ang (2 km/s)
+ dy = 0.6229 arcsec (see table below)
  + range is 0.6211 to 0.6249
+ PA does vary from slit to slit: 3.13 to 3.18
+ In both cases, over 512 pixels, the variation in PA and dy correspond to only a couple of pixels
+ Now we gather all the needed information into the following table
  + We calculate the (RA0, Dec0) of the slit center (taking into account the =jshift= values)
  + We calculate the pixel scale and PA of the slit
  + We calculate a total weight by multiplying together the inter-position and the image-to-spectrum values

#+name: vertical-all-parameters
#+header: :var intable=vertical-image-and-fullspec
#+BEGIN_SRC python :return table :dir ~/Dropbox/SPMJAN10/reducciones/posiciones :exports both
  import numpy as np
  from astropy.io import fits
  from astropy.wcs import WCS

  table = [['image', 'spectrum', 'RA0', 'Dec0', 'dy', 'PA', 'weight'], None]
  for imid, specid, islit, jshift, fac, bfac in intable:
      fn = 'spm{}-ardec.fits'.format(imid)
      hdu, = fits.open(fn)

      #
      # Find pixel scale along slit and position angle of slit
      #
      dRA_arcsec = hdu.header['CD1_2']*3600*np.cos(np.radians(hdu.header['CRVAL2']))
      dDEC_arcsec = hdu.header['CD2_2']*3600
      dy = np.hypot(dRA_arcsec, dDEC_arcsec)
      PA = np.degrees(np.arctan2(dRA_arcsec, dDEC_arcsec))

      #
      # Find the RA and Dec of the spectral slit center
      #

      # Pixel coords of spectrum slit center on image (in FITS 1-based convention)
      i0, j0 = islit, 0.5*(1 + hdu.header['NAXIS2']) - jshift

      # Convert to world coordinates
      wcs = WCS(hdu.header)
      # Crazy packing/unpacking required to use single scalar coords
      (RA0, Dec0), = wcs.all_pix2world([[i0, j0]], 1)

      # Test it by hand using small-patch-of-sky approximation
      c = 1./np.cos(np.radians(-5.42))
      RA1 = (hdu.header['CRVAL1']
             + c*hdu.header['CD1_1']*(i0 - hdu.header['CRPIX1'])
             + c*hdu.header['CD1_2']*(j0 - hdu.header['CRPIX2']))
      Dec1 = (hdu.header['CRVAL2']
              + hdu.header['CD2_1']*(i0 - hdu.header['CRPIX1'])
              + hdu.header['CD2_2']*(j0 - hdu.header['CRPIX2']))
      assert(abs(RA1 - RA0) < 1e-6 )
      assert(abs(Dec1 - Dec0) < 1e-6 )

      #
      # Find total weight factor, combining inter-image factor with the
      # image-to-spectrum factor
      #
      weight = (fac/4.4)/bfac
 
      table.append([imid, int(imid)+1,
                    '{:.5f}'.format(RA0),
                    '{:.5f}'.format(Dec0),
                    '{:.4f}'.format(dy), '{:.3f}'.format(PA),
                    '{:.4f}'.format(weight),
      ])
#+END_SRC

#+RESULTS: vertical-all-parameters
| image | spectrum |      RA0 |     Dec0 |     dy |    PA | weight |
|-------+----------+----------+----------+--------+-------+--------|
|   202 |      203 | 83.62012 | -5.42575 | 0.6246 | 3.132 | 0.7755 |
|   124 |      125 | 83.61775 | -5.42765 | 0.6222 | 3.379 | 0.4288 |
|   206 |      207 | 83.61646 | -5.42573 | 0.6227 | 3.300 | 0.8803 |
|   128 |      129 | 83.61513 | -5.42787 | 0.6231 | 3.322 | 0.3720 |
|   133 |      134 | 83.61537 | -5.42226 | 0.6231 | 3.259 | 0.7067 |
|   210 |      211 | 83.61386 | -5.42573 | 0.6229 | 3.283 | 0.9794 |
|   137 |      138 | 83.61278 | -5.42226 | 0.6232 | 3.270 | 0.4106 |
|   214 |      215 | 83.61140 | -5.42547 | 0.6247 | 3.132 | 0.8733 |
|   145 |      146 | 83.61005 | -5.42080 | 0.6218 | 3.358 | 0.0877 |
|   248 |      249 | 83.60913 | -5.42673 | 0.6231 | 3.218 | 0.5523 |
|   219 |      220 | 83.60811 | -5.42615 | 0.6227 | 3.331 | 0.9886 |
|   157 |      158 | 83.60713 | -5.42289 | 0.6211 | 3.373 | 0.2354 |
|   236 |      237 | 83.60653 | -5.42631 | 0.6233 | 3.220 | 0.8508 |
|   240 |      241 | 83.60476 | -5.42649 | 0.6236 | 3.256 | 0.6566 |
|   244 |      245 | 83.60297 | -5.42626 | 0.6249 | 3.201 | 0.5350 |
|   252 |      253 | 83.60148 | -5.42675 | 0.6229 | 3.335 | 0.7314 |


**** Offset along slit                                             :noexport:
:PROPERTIES:
:ID:       8685D060-12A9-4E73-B069-11D5315ED8EB
:END:
+ spm124
  + Star position is y = 270.5
  + Same star position in spec125-ha is y = 325
  + Shift of 325 - 270.5 = 54.5 pixels
+ spm137
  + Star position is y = 291
  + In spec138-ha it is y = 351
  + Shift of = 351 - 291 = 60

| spm124 | 270.5 | spec125 |   325 | 54.5 |
| spm202 |   359 | spec203 | 411.5 | 52.5 |
| spm206 |   104 | spec207 |   158 |   54 |
| spm137 |   291 | spec138 |   351 |   60 |
| spm219 | 320.5 | spec220 |   378 | 57.5 |
#+TBLFM: $5=$4 - $2

+ Unfortunately, the offset varies from spectrum to spectrum, which is odd
+ [2015-08-18 Tue] This is now calculated more rigorously [[id:0B8D02D8-4C57-48A1-8F17-6AD60BFA1A7B][above]]

*** Which to use
**** Positions in Alba's set that are acceptable
202, 124, 206, 133(+), 210, 137, 214, 248(+), 219, 236, 240, 244, 252

|  ID |      |  Norm | Inverse | Bright |  Norm | Inverse |
|-----+------+-------+---------+--------+-------+---------|
| 202 | 2083 | 0.875 |   1.143 |   2087 | 0.939 |   1.065 |
| 124 | 1900 | 0.699 |   1.431 |   1879 | 0.726 |   1.377 |
| 206 | 2089 | 0.880 |   1.136 |   2101 | 0.953 |   1.049 |
| 128 | 1558 | 0.372 |   2.688 |    nan |   nan |     nan |
| 133 | 1819 | 0.622 |   1.608 |   1780 | 0.624 |   1.603 |
| 210 | 2192 | 0.979 |   1.021 |   2141 | 0.994 |   1.006 |
| 137 | 1843 | 0.645 |   1.550 |   1913 | 0.760 |   1.316 |
| 214 | 2148 | 0.937 |   1.067 |   2125 | 0.977 |   1.024 |
| 145 | 1372 | 0.193 |   5.181 |    nan |   nan |     nan |
| 248 | 1640 | 0.450 |   2.222 |   1615 | 0.455 |   2.198 |
| 219 | 2214 |     1 |       1 |   2124 | 0.976 |   1.025 |
| 157 | 1324 | 0.148 |   6.757 |    nan |   nan |     nan |
| 236 | 2100 | 0.891 |   1.122 |   2070 | 0.921 |   1.086 |
| 240 | 2143 | 0.932 |   1.073 |   2147 |     1 |       1 |
| 244 | 2080 | 0.872 |   1.147 |   2017 | 0.867 |   1.153 |
| 252 | 1792 | 0.596 |   1.678 |   1792 | 0.637 |   1.570 |
#+TBLFM: $3=($-1 - 1170)/(2214 - 1170);f3::$4=1/$-1;f3::$6=($-1 - 1170)/(2147 - 1170);f3::$7=1/$-1;f3

+ The Inverse column /used/ to agree closely with Alba's values
+ But now it does not, because I realised that the radec images have not had the bias subtracted!
+ [2015-08-17 Mon] Dones it again to include more positions - new version is in columns 2 to 4

**** Positions in Alba's set that are bad
128(+), 101, 145, 157, 173
***** Rehabilitation of some of these positions
+ From my experience with the image-spectrum calibration, there is often a big difference between the quality of the image and that of hte spectrum
+ So we shouldn't rule out a position, just based on a poor image
+ Worth saving:
  + 128 :: slots in right next to 133
  + 145 :: goes just before 248
  + 157 :: goes before 236
+ Still terrible: 101 (no spectrum), 173 (just bad)
**** Positions over to the NE
spm078, spm085
**** Other positions omitted ny Alba
+ spm142 - no spectrum
+ spm150 - ha spec exists, but looks weak and Tere says no
+ spm154 - no spectrum
+ spm161 - same as 150 but even worse
+ spm224 - has sii spec but no ha
+ spm231 - no spectrum
*** Message from Teresa [2010-02-18 Thu]
: Acabo de terminar las reducciones de las observaciones de Enero. Al
: final nos quedamos con 16 posiciones, eliminé 7 posiciones
: porque las observé con muchas nubes por lo que no obtuve buenos
: resultados, lo bueno fué que en la siguiente noche pude obtener
: estas posiciones o cercanas a ellas. De cualquier manera las reduje
: por si decidimos incluirlas.
: 
: Las reducciones estan en: /fs/tungol/home0/LEEDS/teresa/SPMENE10/reducciones
: 
: incluyo también la bitacora en pdf. Las posiciones que no tomé en
: cuenta para hacer los mapas fueron:
: 
: No incluidas        Slit cercana o casi en la misma posición que la anterior
: spm128                   spm133 (se ve mucho mejor que spm128)
: spm231                   spm248
: spm150                   spm224
: spm157                   spm236
: spm173                   spm252
: spm161
: spm129                   spm133
: 
: Hice la astrometría, las imagen+slit corregidas están en el directorio
: llamado "posiciones" adentro del direcotorio "reducciones"
: También hice dos posiciones al Este de la región observada. Están la
: oeste de HH 505, las observé en Halpha y [S II]:
: spm078 (image+slit), spm085 (image+slit). Podemos obtener la densidad
: en estas posiciones.
: 
: Para la posición de spm219 tomé los espectros en Ha (spm220,221),
: [SII] (spm225,226) y [OIII] (spm228,229)
: Los espectros corregidos en longitud de onda los puse en:
: 
: /fs/tungol/home0/LEEDS/teresa/SPMENE10/observaciones/SPM{ha,nii,siis,siil,oiii}
: 
: Después de hacer todo el trabajo hice el primer intento de los mapas
: de momentos de Halpha y [NII] :D a ver que te parecen,
: todos los archivos  estan en
: /fs/tungol/home0/LEEDS/teresa/SPMENE10/observaciones:
: 
: {ha,nii}_{-100-040,-060+000,+000+060,+060+140,-020+040).wisomom-sum-fake.fits
: 
: haciendo un smooth:
: 
: {ha,nii}_{-100-040,-060+000,+000+060,+060+140,-020+040).wisomom-sum-smooth2d.fits
: 
: Hice también en rangos de 20 km/s para poder hacer los mapas a color
: (no me quedarón también como a ti!)
: que son los que anexo a este email.

* Making spectral maps
+ The plan is to start with a fine orthogonal RA-dec grid
  + Place all the slits onto there by looping over slit pixels and painting all the grid pixels that fall in each
  + Leave grid pixels transparent where no slit falls
+ Then do the multi-resolution thing
  + As in [[id:E1B9B2C8-1CDE-407B-B9FE-4E31144F328C][Rebinning the maps]] in orion tsquared notes
  + Which makes use of [[file:~/Work/RubinWFC3/Tsquared/rebin_utils.py][file:~/Work/RubinWFC3/Tsquared/rebin_utils.py]]
+ This should give a map with all the holes filled in at lower resolution
+ To start with we will work with the original spectra that I already have
  + Later, we should switch to the bg-subtracted and brightness-corrected ones that Alba has
** Define the output grid
+ 1 arcsec is
  + 2.778e-4 deg declination
  + 2.765e-4 deg RA
+ We will try a grid with 0.5 arcsec pixels that is 1024 x 1024, which should comfortably enclose all of the slits
+ AR reference of the horizontal slits is 83.6158 +/- 0.0019
  + AR range of vertical slits is 83.6016 to 83.6205: 68 cos(-5.4150) = 67.7 arcsec
+ Dec reference of vertical slits is -5.4150 +/- 0.0006
  + Dec range of horizontal slits is -5.4409 to -5.4155 = 91.44 arcsec
  + Actually Dec value of the vertical slits is a bit lower now that I have taken into account the image-spectrum shift 
+ So we use
  + CRPIX1 = CRPIX2 = 256.5
  + CRVAL1 = 83.61, CRVAL2 = -5.423
  + CDELT1 = -0.5/3600, CDELT2 = 0.5/3600
  + PC1_1 = 1.0, PC1_2 = 0.0
  + PC2_1 = 0.0, PC2_2 = 1.0
+ Note that the WCS matrix should be given in arcdegrees - the translation to degrees of RA is done automatically (and it doesn't matter much anyway, since we are near the equator)

** Test with the velocity-integrated emission
:PROPERTIES:
:dir:      ~/Dropbox/SPMJAN10/reducciones
:END:

Some positions are a bit problematic - try missing them out:
#+name: positions-to-drop
+ 248


#+name: create-slit-map
#+header: :var ignore=positions-to-drop
#+header: :var vtab=vertical-all-parameters
#+header: :var vmin=-1000 vmax=1000 label="sum"
#+BEGIN_SRC python :results output
  import numpy as np
  from astropy.io import fits
  from astropy.wcs import WCS

  #
  # First set up WCS for the output image
  #

  NX, NY = 1024, 1024
  dRA, dDec = -0.5/3600., 0.5/3600.
  RA0, Dec0 = 83.61, -5.423
  w = WCS(naxis=2)
  w.wcs.crpix = [0.5*(1 + NX), 0.5*(1 + NY)]
  w.wcs.cdelt = [dRA, dDec]
  w.wcs.crval = [RA0, Dec0]
  w.wcs.ctype = ['RA---TAN', 'DEC--TAN']

  outimage = np.zeros((NY, NX))
  outweights = np.zeros((NY, NX))

  # Create world coord arrays for output image
  II, JJ = np.meshgrid(np.arange(NX), np.arange(NY))
  RA, Dec = w.all_pix2world(II, JJ, 0)

  slit_width = 2.0                # width in arcsec of 150 micron slit

  light_speed = 2.99792458e5
  wavrest = 6562.7910
  heliocentric_correction = 0.0   # I need to find this
  vmin, vmax = float(vmin), float(vmax)
  for imid, specid, ra0, dec0, dy, PA, weight in vtab:
      if int(imid) in ignore:
          continue  # drop some positions
      # Unpack floats from strings in table row
      ra0, dec0, dy, PA, weight = [float(_) for _ in (ra0, dec0, dy, PA, weight)]
      # Open H alpha slit spectrum
      spechdu, = fits.open('spec{}-ha.fits'.format(specid))

      # Create velocity array from header
      nwav, k0, wav0, dwav = [spechdu.header[kwd+'1']
                              for kwd in ('NAXIS', 'CRPIX', 'CRVAL', 'CDELT')]
      wavs = wav0 + (np.arange(nwav) - k0 + 1)*dwav
      vels = heliocentric_correction + light_speed*(wavs - wavrest)/wavrest
      # Find indices corresponding to velocity limits
      k1 = (vels < vmin).sum()
      k2 = (vels <= vmax).sum()
      print('Velocities used', vels[k1:k2])

      # Sum spectrum over all wavelengths
      profile = spechdu.data[:, k1:k2].sum(axis=1)

      # Transform output grid coords into slit frame offsets in arcsec
      # XX, YY are intermediate offset coordinates along RA, Dec axes
      XX = 3600*(RA - ra0)*np.cos(np.radians(Dec))
      YY = 3600*(Dec - dec0)
      # Precalculate geometric factors for rotation to slit frame
      c, s = np.cos(np.radians(PA)), np.sin(np.radians(PA))
      # X is ordinate perpendicular to slit
      X = XX*c - YY*s
      # Y is ordinate along slit
      Y = YY*c - XX*s

      # Mask for all output pixels that fall in the slit
      slitmask = abs(X) <= 0.5*slit_width
      # cycle over all slit y pixels
      for j, intensity in enumerate(profile):
          # Offset from slit center
          y = (j - 255.5)*dy
          # Mask for output pixels that fall in this slit pixel
          pixmask = slitmask & (abs(Y - y) <= 0.5*dy)
          # Fill in the output intensity and weight arrays
          outimage[pixmask] += intensity
          outweights[pixmask] += weight

  # Save everything as different images in a single fits file:
  # 1. The sum of the raw slits 
  # 2. The weights
  # 3. The slits normalized by the weights
  fits.HDUList([
      fits.PrimaryHDU(),
      fits.ImageHDU(header=w.to_header(), data=outimage, name='slits'),
      fits.ImageHDU(header=w.to_header(), data=outweights, name='weight'),
      fits.ImageHDU(header=w.to_header(), data=outimage/outweights, name='scaled'),
      ]).writeto('all-vert-{}.fits'.format(label), clobber=True)


#+END_SRC

#+RESULTS:

+ The first image in the file is what can be used to combine with more data, for instance the horizontal slits
+ The third image is what should be used in the rebinning process (together with the second image, the weights)

This shows the scaled image in ds9
#+BEGIN_SRC sh :results silent
xpaset -p ds9 fits $PWD/all-vert-sum.fits[3]
#+END_SRC


** Try to use different velocity ranges
:PROPERTIES:
:dir:      ~/Dropbox/SPMJAN10/reducciones
:END:

+ It would be more efficient to do these all at the sane time, but for the time being I will do them separately
+ Although the noisiest slit looked fine on the integrated maps, it makes a mess of the velocity channels where the emission is faint

#+name: noisy-slits
+ 145

#+call: create-slit-map(vmin=-200, vmax=-50, label="blue", ignore=noisy-slits) :results silent

#+BEGIN_SRC sh :results silent
xpaset -p ds9 fits $PWD/all-vert-blue.fits[3]
#+END_SRC

+ Try some blue wing 20 km/s channels

#+call: create-slit-map(vmin="-40", vmax="-20", label="b30", ignore=noisy-slits) :results silent
#+call: create-slit-map(vmin="-60", vmax="-40", label="b50", ignore=noisy-slits) :results silent
#+call: create-slit-map(vmin="-80", vmax="-60", label="b70", ignore=noisy-slits) :results silent

+ And some line core channels
#+call: create-slit-map(vmin="20", vmax="40", label="r30", ignore=noisy-slits) :results silent
#+call: create-slit-map(vmin="0", vmax="20", label="r10", ignore=noisy-slits) :results silent
#+call: create-slit-map(vmin="-20", vmax="0", label="b10", ignore=noisy-slits) :results silent


#+BEGIN_SRC sh :results silent
xpaset -p ds9 rgb new
xpaset -p ds9 fits $PWD/all-vert-b30.fits[3]
xpaset -p ds9 rgb green
xpaset -p ds9 fits $PWD/all-vert-b50.fits[3]
xpaset -p ds9 rgb blue
xpaset -p ds9 fits $PWD/all-vert-b70.fits[3]
#+END_SRC

#+BEGIN_SRC sh :results silent
xpaset -p ds9 rgb new
xpaset -p ds9 fits $PWD/all-vert-r30.fits[3]
xpaset -p ds9 scale linear
xpaset -p ds9 scale limits 0 50000
xpaset -p ds9 rgb green
xpaset -p ds9 fits $PWD/all-vert-r10.fits[3]
xpaset -p ds9 scale linear
xpaset -p ds9 scale limits 0 15000
xpaset -p ds9 rgb blue
xpaset -p ds9 fits $PWD/all-vert-b10.fits[3]
xpaset -p ds9 scale linear
xpaset -p ds9 scale limits 0 6000
#+END_SRC


#+call: multi-smooth(label="b30") :results silent 
#+call: multi-smooth(label="b50") :results silent 
#+call: multi-smooth(label="b70") :results silent 

#+call: multi-smooth(label="r30") :results silent 
#+call: multi-smooth(label="r10") :results silent 
#+call: multi-smooth(label="b10") :results silent 

#+BEGIN_SRC sh :results silent
xpaset -p ds9 rgb new
xpaset -p ds9 fits $PWD/all-vert-b30-bin016.fits['scaled']
xpaset -p ds9 rgb green
xpaset -p ds9 fits $PWD/all-vert-b50-bin016.fits['scaled']
xpaset -p ds9 rgb blue
xpaset -p ds9 fits $PWD/all-vert-b70-bin016.fits['scaled']
#+END_SRC


+ Display the multigrid smoothed channel maps
#+BEGIN_SRC sh :results silent
xpaset -p ds9 rgb new
xpaset -p ds9 fits $PWD/all-vert-b30-multibin.fits
xpaset -p ds9 scale linear
xpaset -p ds9 rgb green
xpaset -p ds9 fits $PWD/all-vert-b50-multibin.fits
xpaset -p ds9 scale linear
xpaset -p ds9 rgb blue
xpaset -p ds9 fits $PWD/all-vert-b70-multibin.fits
xpaset -p ds9 scale linear
#+END_SRC

#+BEGIN_SRC sh :results silent
xpaset -p ds9 rgb new
xpaset -p ds9 fits $PWD/all-vert-r30-multibin.fits
xpaset -p ds9 scale linear
xpaset -p ds9 scale limits 0 50000
xpaset -p ds9 rgb green
xpaset -p ds9 fits $PWD/all-vert-r10-multibin.fits
xpaset -p ds9 scale linear
xpaset -p ds9 scale limits 0 15000
xpaset -p ds9 rgb blue
xpaset -p ds9 fits $PWD/all-vert-b10-multibin.fits
xpaset -p ds9 scale linear
xpaset -p ds9 scale limits 0 6000
#+END_SRC




* The multigrid smoothing method
:PROPERTIES:
:dir:      ~/Dropbox/SPMJAN10/reducciones
:END:

#+name: multi-smooth
#+BEGIN_SRC python :var label="sum" :results output
  import sys
  sys.path.append('/Users/will/Work/RubinWFC3/Tsquared')
  from rebin_utils import downsample, oversample
  from astropy.io import fits

  nlist = [1, 2, 4, 8, 16, 32]

  infile = 'all-vert-{}.fits'.format(label)

  hdulist = fits.open(infile)
  hdr = hdulist['scaled'].header
  im = hdulist['scaled'].data
  w = hdulist['weight'].data
  m = w > 0.0

  for n in nlist:
      im[~m] = 0.0
      outfile = infile.replace('.fits', '-bin{:03d}.fits'.format(n))
      print('Saving', outfile)
      # Save both the scaled image and the weights, but at the full resolution
      fits.HDUList([
          fits.PrimaryHDU(),
          fits.ImageHDU(data=oversample(im, n), header=hdr, name='scaled'),
          fits.ImageHDU(data=oversample(w, n), header=hdr, name='weight'),
      ]).writeto(outfile, clobber=True)
      # Now do the rebinning by a factor of two
      [im,], m, w = downsample([im,], m, weights=w)

#+END_SRC

#+RESULTS: multi-smooth
: Saving all-vert-sum-bin001.fits
: Saving all-vert-sum-bin002.fits
: Saving all-vert-sum-bin004.fits
: Saving all-vert-sum-bin008.fits
: Saving all-vert-sum-bin016.fits
: Saving all-vert-sum-bin032.fits

#+BEGIN_SRC sh :results silent
xpaset -p ds9 fits $PWD/all-vert-sum-bin016.fits['scaled']
#+END_SRC

+ Unfortunately, the weights increase a lot with the binning - more than they ought to.
+ The problem is that the pixels at the finest grid levels are not independent, since many of them come from the same pixel of the slit spectrum
+ However, the algorithm does not know this and so adds them up when it rebins to the next coarser grid
+ This will be a problem if we want to combine the different levels and impose a minimum weight
  + An easy solution would be to have the minimum weight vary per level

#+BEGIN_SRC python :results silent
  from astropy.io import fits
  import numpy as np
  nlist = [1, 2, 4, 8, 16]
  minweights = [0.5, 1.0, 2.0, 2.0, 2.0, 2.0]
  outim = np.zeros((1024, 1024))
  for n, minw in reversed(list(zip(nlist, minweights))):
      fn = 'all-vert-sum-bin{:03d}.fits'.format(n)
      hdulist = fits.open(fn)
      im = hdulist['scaled'].data
      hdr = hdulist['scaled'].header
      w = hdulist['weight'].data
      m = w*im >= minw*1e5
      outim[m] = im[m]
  fits.PrimaryHDU(header=hdr, data=outim).writeto('all-vert-sum-multibin.fits', clobber=True)
#+END_SRC


And here is a version for the velocity channels

#+name: vel-channels
+ r30
+ r10
+ b10
+ b30
+ b50
+ b70


#+name: multigrid-combine
#+BEGIN_SRC python :var labels = vel-channels :results silent
  from astropy.io import fits
  import numpy as np
  nlist = [1, 2, 4, 8, 16]
  minweights = [0.5, 1.0, 2.0, 2.0, 2.0, 2.0]
  outim = np.zeros((1024, 1024))
  for label in labels:
      for n, minw in reversed(list(zip(nlist, minweights))):
          fn = 'all-vert-{}-bin{:03d}.fits'.format(label, n)
          hdulist = fits.open(fn)
          im = hdulist['scaled'].data
          hdr = hdulist['scaled'].header
          w = hdulist['weight'].data
          m = w*im >= minw*1000
          outim[m] = im[m]
      fits.PrimaryHDU(header=hdr, data=outim).writeto(
          'all-vert-{}-multibin.fits'.format(label), clobber=True)
#+END_SRC



* T diagnostics from linewidths
+ We could repeat what we did for the Teresa Atlas Paper, but we only have one slit with [O III] spectrum
+ For the jet knots, assuming they are kinematically homogeneous, we should be able to measure the T from
+ Compact knot in slit spec166
  + FWHM in [N II] = 12.76 km/s
  + FWHM in Ha = 23.77 km/s
  + => thermal FWHM = sqrt((23.77**2 - 12.76**2) (14/13)) = 20.8 km/s
  + So basically 1e4 K, which is not surprising


* Coordinates of the slits
+ Data received from Alba [2015-08-11 Tue]

** Description from Alba
: Todos los datos están en:
: /fs/posgrado01/other0/albafm/WesternShocks/3.CuboWS/0.Datos
: Diferencio entre especros e imagenes y luego entre los del 2010 (verticales) y
: 2013 (horizontales)
: Todos los espectros tienen la sustraccion del continuo (*nc*) y los del 2010
: además tiene el factor de calidad (aplicado entre ellos y a todos los de esa
: campaña de observacion, son *cc*fits)
: 
: Por ultimo te adjunto tabla las coordenadas de cada posicion de las rendijas.



** Brightness correction factors
+ The 2010 data in =3.CuboWS/0.Datos= are =.nc.cc.= have already had this applied
+ The prior stage (just =.nc.=) is in =2.Datos2010/1.PreparandoDatos/1.SustraccionContinuo=
+ The factors are in [[file:/ssh:nil:/fs/posgrado01/other0/albafm/WesternShocks/2.Datos2010/1.PreparandoDatos/2.IgualandoCalidad/intensidades.dat][intensidades.dat]]
  + Transposed version of this table below
  + The factors multiply the observed intensities
+ The 2013 data don't seem to have any brightness correction

| Imagen | I. original | I. corregida |  Factor |
|--------+-------------+--------------+---------|
|    101 |     2149.52 |      2180.37 | 1.01435 |
|    124 |     1936.37 |      2180.37 | 1.12601 |
|    128 |     1567.50 |      2180.37 | 1.39099 |
|    133 |     1814.61 |      2180.37 | 1.20156 |
|    137 |     1939.18 |      2180.37 | 1.12438 |
|    145 |     1361.85 |      2180.37 | 1.60103 |
|    157 |     1323.03 |      2180.37 | 1.64801 |
|    173 |     1249.18 |      2180.37 | 1.74544 |
|    202 |     2170.67 |      2180.37 | 1.00447 |
|    206 |     2169.70 |      2180.37 | 1.00492 |
|    210 |     2211.48 |      2180.37 | 0.98594 |
|    214 |     2231.37 |      2180.37 | 0.97715 |
|    219 |     2226.34 |      2180.37 | 0.97935 |
|    236 |     2184.94 |      2180.37 | 0.99791 |
|    240 |     2186.48 |      2180.37 | 0.99720 |
|    244 |     2150.31 |      2180.37 | 1.01398 |
|    248 |     1632.71 |      2180.37 | 1.33543 |
|    252 |     1816.34 |      2180.37 | 1.20042 |

** HORIZONTALES 2013

#+name: horizontal-slits
| imagen | Espectro |                 AR |                DEC |
|--------+----------+--------------------+--------------------|
| spm165 | spec166  |            83.6141 |            -5.4409 |
| spm169 | spec170  |            83.6146 |            -5.4382 |
| spm237 | spec238  |            83.6166 |            -5.4361 |
| spm232 | spec233  |            83.6157 |            -5.4321 |
| spm226 | spec227  |            83.6076 |            -5.4294 |
| spm149 | spec150  |            83.6231 |            -5.4239 |
| spm154 | spec155  |            83.6237 |            -5.4226 |
| spm159 | spec160  |            83.6238 |            -5.4201 |
| spm033 | spec034  |            83.6107 |            -5.4165 |
| spm029 | spec030  |            83.6084 |            -5.4155 |
|--------+----------+--------------------+--------------------|
|        |          | 83.6158 +/- 0.0019 | -5.4275 +/- 0.0029 |
#+TBLFM: @12$3..@12$4=vmeane(@I..@II);f4

					
					
** VERTICALES 2010
+ From the region file [[file:/ssh:nil:/fs/posgrado01/other0/albafm/WesternShocks/3.CuboWS/1.Posiciones/pos_todas.reg][pos_todas.reg]] it looks like the PA = 3.03 deg

#+name: vertical-slits
| imagen | Espectro |                 AR |                DEC |  Factor |
|--------+----------+--------------------+--------------------+---------|
| spm252 | spec253  |            83.6016 |            -5.4149 | 1.20042 |
| spm173 | spec174  |            83.6020 |            -5.4108 | 1.74544 |
| spm244 | spec245  |            83.6031 |            -5.4152 | 1.01398 |
| spm240 | spec241  |            83.6053 |            -5.4153 | 0.99720 |
| spm236 | spec237  |            83.6071 |            -5.4155 | 0.99791 |
| spm157 | spec158  |            83.6078 |            -5.4118 | 1.64801 |
| spm219 | spec220  |            83.6087 |            -5.4163 | 0.97935 |
| spm248 | spec249  |            83.6091 |            -5.4150 | 1.33543 |
| spm145 | spec146  |            83.6106 |            -5.4109 | 1.60103 |
| spm214 | spec215  |            83.6119 |            -5.4160 | 0.97715 |
| spm137 | spec138  |            83.6133 |            -5.4120 | 1.12438 |
| spm210 | spec211  |            83.6143 |            -5.4163 | 0.98594 |
| spm101 | spec102  |            83.6149 |            -5.4177 | 1.01435 |
| spm128 | spec129  |            83.6156 |            -5.4181 | 1.39099 |
| spm133 | spec134  |            83.6159 |            -5.4123 | 1.20156 |
| spm206 | spec207  |            83.6171 |            -5.4165 | 1.00492 |
| spm124 | spec125  |            83.6184 |            -5.4183 | 1.12601 |
| spm202 | spec203  |            83.6205 |            -5.4167 | 1.00447 |
|--------+----------+--------------------+--------------------+---------|
|        |          | 83.6110 +/- 0.0014 | -5.4150 +/- 0.0006 |         |
#+TBLFM: @20$3..@20$4=vmeane(@I..@II);f4



* Modifying org export to include header arguments                 :noexport:
Based on http://kitchingroup.cheme.cmu.edu/blog/2014/09/22/Showing-what-data-went-into-a-code-block-on-export/


** This is all copied from John Kitchin's page
Here is how we can get a list of the table-names indicating their name or that they are results (results are enclosed in ()).

#+BEGIN_SRC emacs-lisp :results list
(org-element-map (org-element-parse-buffer) 'table
  (lambda (element)     
    (or (org-element-property :name element) (org-element-property :results element))))
#+END_SRC

#+RESULTS:
- vertical-image-and-fullspec
- ("vertical-all-parameters")
- horizontal-slits
- vertical-slits
- ("")

Similarly, here is the list of parameters for each block.

#+BEGIN_SRC emacs-lisp :results list
(org-element-map (org-element-parse-buffer) 'src-block
  (lambda (element)     
    (org-element-property :parameters element)))
#+END_SRC

#+RESULTS:
- :return figfile :results file
- :return table :dir ~/Dropbox/SPMJAN10/reducciones/posiciones :exports both
- :results output
- :results silent
- :results output
- :results silent
- :results output
- :results list


** My attempt to extend it to '#+header:' elements
#+BEGIN_SRC emacs-lisp :results list
  (org-element-map (org-element-parse-buffer) 'src-block
    (lambda (element)
    (org-element-property :header element)))
#+END_SRC

#+RESULTS:
- (":var table=vertical-image-and-fullspec")
- (":var intable=vertical-image-and-fullspec")
- (":var vtab=vertical-all-parameters" ":var ignore=positions-to-drop")



** And to named plain lists
#+BEGIN_SRC emacs-lisp :results list
(org-element-map (org-element-parse-buffer) 'plain-list
  (lambda (element)     
    (or (org-element-property :name element) (org-element-property :results element))))
#+END_SRC

#+RESULTS:
- positions-to-drop
- ("")
- ("")
- ("")


** Now my version of Kitchin's output filters

#+BEGIN_SRC emacs-lisp
  (defun ox-mrkup-filter-table (text back-end info)
    (let ((tblname (pop tblnames)))
      (message "tblname is \"%s\"" tblname)
      ; pop does not remove nil from the list, so we do it here.
      (when (null tblname) (setq tblnames (cdr tblnames)))
      (cond
       ((listp tblname)  ; from results
        (concat (format "<br><pre class=\"example\">Results table name: %s</pre>" (car tblname)) text))
       ((null tblname)   ; no name
        text)
       (t ; everything else
        (concat (format "<br><pre class=\"example\">Table name: %s</pre>" tblname) text)))))

  (defun ox-mrkup-filter-plain-list (text back-end info)
    (let ((listname (pop listnames)))
      (message "listname is \"%s\"" listname)
      ; pop does not remove nil from the list, so we do it here.
      (when (null listname) (setq listnames (cdr listnames)))
      (cond
       ((null listname)   ; no name
        text)
       (t ; everything else
        (concat (format "<br><pre class=\"example\">List name: %s</pre>" listname) text)))))

  (defun ox-mrkup-filter-src-block (text back-end info)
    (let ((params (pop src-params))
          (hparams (pop hdr-params))
          (lang (pop src-langs)))
      (when (null params) (setq src-params (cdr src-params)))
      (when (null hparams) (setq hdr-params (cdr hdr-params)))
      (if params  
          (concat (format "<pre class=\"example\">Language = %s\nParameters = %s\nHeader = %s</pre>" lang params hparams) text)
        text)))

  ;; preprocess to get table names, src parameters and languages.
  (let ((tblnames (org-element-map (org-element-parse-buffer) 'table
                    (lambda (element)     
                      (or (org-element-property :name element)                    
                          (org-element-property :results element)))))

        (listnames (org-element-map (org-element-parse-buffer) 'plain-list
                    (lambda (element)     
                      (org-element-property :name element))))
      
        (src-params (org-element-map (org-element-parse-buffer) 'src-block
                      (lambda (element)     
                        (org-element-property :parameters element))))

        (hdr-params (org-element-map (org-element-parse-buffer) 'src-block
                      (lambda (element)     
                        (org-element-property :header element))))

        (src-langs (org-element-map (org-element-parse-buffer) 'src-block
                     (lambda (element)     
                       (org-element-property :language element))))

        ;; register the filters
        (org-export-filter-table-functions '(ox-mrkup-filter-table))
        (org-export-filter-plain-list-functions '(ox-mrkup-filter-plain-list))
        (org-export-filter-src-block-functions '(ox-mrkup-filter-src-block)))

    ;; and export the result
    (browse-url (org-export-to-file 'html "alba-orion-west.html")))
#+END_SRC

#+RESULTS:
: #<process open alba-orion-west.html>

